import {Injectable} from '@angular/core';
import {Headers, Http} from '@angular/http';

import 'rxjs/add/operator/toPromise';

import {Game} from '../entity/game';
import {Weather, iWeatherReport} from '../entity/weather';
import {Dragon} from "../entity/dragon";
import {Engagement} from "../entity/engagement";

declare var xml2json: any;  // Declare an "anchor" variable to invoke external 3rd party lib "assets/js/xml2json.js".

@Injectable()
export class HttpService {
    private urlNewGame = 'https://www.dragonsofmugloar.com/api/game';
    private urlWeather = 'https://www.dragonsofmugloar.com/weather/api/report';
    private headers = new Headers({'Content-Type': 'application/json'});

    constructor(private http: Http) {
        /*
         * Because this app uses Angular2 in-memory-data API for local storage
         * to mimic "real" game's backend service, pass this option
         * to allow http service to process urls that are outside the grasp of in-memory-data.
         * */
        http.post('commands/config', '{"passThruUnknownUrl":true}');
    }

    getGame(): Promise<Game> {
        return this.http
            .get(this.urlNewGame)  /* Returns an RxJS Observable */
            .toPromise()         /* Convert Observable to Promise */
            .then(
                response => {
                    let resp = response.json();
                    let game: Game;
                    let id, knight;
                    if (resp) {
                        id = resp.gameId;
                        knight = resp.knight;

                        if (id && knight) {
                            game = new Game(id, knight);
                        } else {
                            throw new Error("Failed to start a new game, because 'gameId' ir 'knight' properties are missing.");
                        }
                    } else {
                        throw new Error("Failed to start a new game, because response is empty or in an unexpected format.");
                    }
                    return game;
                }
            )
            .catch(this.handleError);
    }

    getWeather(gameId: string): Promise<Weather> {
        const url = `${this.urlWeather}/${gameId}`;
        let headers = this.headers;
        headers.append('Accept', 'application/xml');
        return this.http
            .get(url, {headers: headers})
            .toPromise()
            .then(response => {
                let weather;

                try {
                    // Calling external 3rd party library to parse, then convert XML response into a JSON object.
                    let objWeatherReport = <iWeatherReport>JSON.parse(xml2json(response.text(), '  '));
                    weather = new Weather(objWeatherReport);
                } catch (error) {
                    throw new Error("Failed to process weather report response due ".concat(error));
                }

                return weather;
            })
            .catch(this.handleError);
    }

    sendDragon(gameId: string, dragon: Dragon): Promise<Engagement> {
        const url = `${this.urlNewGame}/${gameId}/solution`;

        /* In case the knight doesn't wish to know the dragon's name (and other traits) that ate him. */
        // delete dragon.name;
        // delete dragon.color;
        // delete dragon.title;

        let objDragon = {
            dragon: dragon
        };

        return this.http
            .put(url, JSON.stringify(objDragon), {headers: this.headers})
            .toPromise()
            .then(response => {
                    let engagement: Engagement = new Engagement(response.json());
                    // We establish, that response' structure comes in the form of the 'Engagement' class.
                    return engagement;
                }
            )
            .catch(this.handleError);
    }

    /**
     * Error handling methods.
     * Normally these should do something meaningful, but in this case low level errors are shown for debugging only,
     * whereas high level user feedback is generated by involved components.
     * */
    handleError(error: any): Promise<any> {
        console.error("[HttpService] %s", error);
        return Promise.reject(error.message || error);
    }
}